Задача 1. Права доступа
Что нужно сделать
Перед вами стоит задача создать и поддерживать специализированный форум. Вы только приступили и сейчас работаете над
действиями, которые могут совершать посетители форума. Для разных пользователей прописаны разные возможности.
Напишите декоратор check_permission, который проверяет, есть ли у пользователя доступ к вызываемой функции,
и если нет, то выдаёт исключение PermissionError.

Пример кода:
user_permissions = ['admin']
@check_permission('admin')
def delete_site():
    print('Удаляем сайт')
@check_permission('user_1')
def add_comment():
    print('Добавляем комментарий')
delete_site()
add_comment()

Результат:
Удаляем сайт
PermissionError: у пользователя недостаточно прав, чтобы выполнить функцию add_comment


Задача 2. Функция обратного вызова
Что нужно сделать
При работе с сетью и веб-сервисами иногда используется функция callback, так называемая функция обратного вызова.
Это функция, которая вызывается при срабатывании определённого события: переходе на страницу, получении сообщения
или окончании обработки процессором. В неё можно передать функцию, чтобы она выполнилась после определённого события.
Это используется, например, в HTTP-серверах в ответ на URL-запросы. Реализуйте такую функцию.

Пример функции:

@callback('//')
def example():
    print('Пример функции, которая возвращает ответ сервера')
    return 'OK'

Основной код:
route = app.get('//')
if route:
    response = route()
    print('Ответ:', response)
else:
    print('Такого пути нет')
Ожидаемый результат: пример функции, которая возвращает ответ сервера.
Ответ: OK.

Подсказка: функция callback, в зависимости от условия, может быть вызвана следующим действием или просто так.


Задача 3. Логирование в формате
Что нужно сделать
Реализуйте декоратор, который будет логировать все методы декорируемого класса (кроме магических методов) и в
который можно передавать формат вывода даты и времени логирования.

Пример кода, передаётся формат «месяц день год — часы:минуты:секунды»:

@log_methods("b d Y — H:M:S")
class A:
    def test_sum_1(self) -> int:
        print('test sum 1')
        number = 100
        result = 0
        for _ in range(number + 1):
            result += sum([i_num ** 2 for i_num in range(10000)])

        return result

@log_methods("b d Y - H:M:S")
class B(A):
    def test_sum_1(self):
        super().test_sum_1()
        print("Наследник test sum 1")


    def test_sum_2(self):
        print("test sum 2")
        number = 200
        result = 0
        for _ in range(number + 1):
            result += sum([i_num ** 2 for i_num in range(10000)])

        return result

my_obj = B()
my_obj.test_sum_1()
my_obj.test_sum_2()


Результат:
Запускается 'B.test_sum_1'. Дата и время запуска: Apr 23 2021 — 21:50:37.
Запускается 'A.test_sum_1'. Дата и время запуска: Apr 23 2021 — 21:50:37.
Тут метод test_sum_1.
Завершение 'A.test_sum_1', время работы = 0,187 s.
Тут метод test_sum_1 у наследника.
Завершение 'B.test_sum_1', время работы = 0,187 s.
Запускается 'B.test_sum_2'. Дата и время запуска: Apr 23 2021 — 21:50:37.
Тут метод test_sum_2 у наследника.
Завершение 'B.test_sum_2', время работы = 0,370 s.

Совет: внимательно пересмотрите видео 29.4, если сталкиваетесь с трудностями в этой задаче.


Задача 4. Синглтон
Что нужно сделать
Синглтон — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр,
и предоставляет к этому экземпляру глобальную точку доступа. Синглтонами мы уже пользовались, к ним относятся,
например, None, True и False. Благодаря тому, что None — синглтон, можно использовать оператор is: он возвращает
True только для объектов, представляющих одну и ту же сущность.

Реализуйте декоратор singleton, который превращает класс в одноэлементный. При множественной инициализации
объекта этого класса будет сохранён только первый инстанс, а все остальные попытки создания будут
возвращать первый экземпляр.

Пример кода:

@singleton
class Example:
    pass

my_obj = Example()
my_another_obj = Example()

print(id(my_obj))
print(id(my_another_obj))

print(my_obj is my_another_obj)


Результат:
1986890616688
1986890616688
True